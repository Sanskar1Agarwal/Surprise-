<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Happy Birthday ðŸŽˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    min-height: 100vh;
    background: linear-gradient(#fff0f5, #ffe4ec);
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: Arial, sans-serif;
}

.page {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 600px;
    padding: 20px;
}

.page.active {
    display: flex;
}

h1 {
    font-size: clamp(32px, 7vw, 56px);
    color: #d6336c;
    margin-bottom: 20px;
    white-space: nowrap;
    text-align: center;
}

button {
    padding: 14px 28px;
    font-size: 18px;
    border: none;
    border-radius: 30px;
    background: #ff4d6d;
    color: white;
    cursor: pointer;
}

button:hover {
    background: #e0315b;
}

canvas {
    width: 100%;
    max-width: 520px;
    height: auto;
    cursor: pointer;
}
</style>
</head>

<body>

<!-- PAGE 1 -->
<div id="page1" class="page active">
    <h1>Happy Birthday ðŸŽˆ</h1>
    <button onclick="goToCake()">Start ðŸŽ‚</button>
</div>

<!-- PAGE 2 -->
<div id="page2" class="page">
    <canvas id="cakeCanvas" width="520" height="520"></canvas>
</div>

<script>
/* ================= PAGE SWITCH ================= */
function goToCake() {
    document.getElementById("page1").classList.remove("active");
    document.getElementById("page2").classList.add("active");
    startMic(); // mic starts ONLY after button click
}

/* ================= CANVAS SETUP ================= */
const canvas = document.getElementById("cakeCanvas");
const ctx = canvas.getContext("2d");

const center = { x: 260, y: 260 };
const radius = 170;
const cakeHeight = 90;
const maxCuts = 6;

let cuts = 0;
let flameOn = true;
let micStarted = false;

/* ================= CAKE DATA ================= */
let slices = [{
    start: 0,
    end: Math.PI * 2,
    offset: 0
}];

/* ================= DRAW ================= */
function drawCake() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    slices.forEach(slice => {
        const mid = (slice.start + slice.end) / 2;
        const ox = slice.offset * Math.cos(mid);
        const oy = slice.offset * Math.sin(mid);

        // Chocolate sponge
        ctx.fillStyle = "#8b4513";
        ctx.beginPath();
        ctx.moveTo(center.x + ox, center.y + oy + cakeHeight);
        ctx.arc(center.x + ox, center.y + oy + cakeHeight, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        // Strawberry cream
        ctx.fillStyle = "#ff8fab";
        ctx.beginPath();
        ctx.moveTo(center.x + ox, center.y + oy);
        ctx.arc(center.x + ox, center.y + oy, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#c9184a";
        ctx.lineWidth = 2;
        ctx.stroke();
    });

    drawCandle();
}

/* ================= CANDLE ================= */
function drawCandle() {
    const x = center.x;
    const y = center.y - radius - 35;

    ctx.fillStyle = "#fff";
    ctx.fillRect(x - 6, y, 12, 35);

    if (flameOn) {
        ctx.fillStyle = "#ffb703";
        ctx.beginPath();
        ctx.ellipse(x, y - 12, 6, 10, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

/* ================= CAKE CUTTING ================= */
function cutCake() {
    if (cuts >= maxCuts) return;

    cuts++;
    const pieces = cuts + 1;
    const step = Math.PI * 2 / pieces;

    slices = [];
    for (let i = 0; i < pieces; i++) {
        slices.push({
            start: i * step,
            end: (i + 1) * step,
            offset: 0
        });
    }

    animateSplit();
}

function animateSplit() {
    let t = 0;
    function anim() {
        t++;
        slices.forEach(s => s.offset = Math.min(40, t * 2));
        drawCake();
        if (t < 20) requestAnimationFrame(anim);
    }
    anim();
}

/* ================= MICROPHONE (ONLY WAY TO BLOW) ================= */
async function startMic() {
    if (micStarted) return;
    micStarted = true;

    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        await audioCtx.resume();

        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;

        const mic = audioCtx.createMediaStreamSource(stream);
        mic.connect(analyser);

        const data = new Uint8Array(analyser.fftSize);

        function listen() {
            analyser.getByteTimeDomainData(data);
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                const v = (data[i] - 128) / 128;
                sum += v * v;
            }
            const rms = Math.sqrt(sum / data.length);

            if (rms > 0.1 && flameOn) {
                flameOn = false;
                drawCake();
            }
            requestAnimationFrame(listen);
        }
        listen();
    } catch (e) {
        console.warn("Microphone blocked or unavailable");
    }
}

/* ================= INTERACTION ================= */
canvas.addEventListener("click", cutCake);

/* Init */
drawCake();
</script>

</body>
</html>
