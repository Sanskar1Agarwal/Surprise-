<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Happy Birthday ðŸŽˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
    body {
        margin: 0;
        min-height: 100vh;
        background: linear-gradient(#fff0f5, #ffe4ec);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Arial, sans-serif;
    }

    .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 600px;
        padding: 20px;
        box-sizing: border-box;
    }

    h1 {
        font-size: clamp(28px, 6vw, 48px);
        color: #d6336c;
        margin-bottom: 16px;
        white-space: nowrap;
        text-align: center;
    }

    canvas {
        width: 100%;
        max-width: 520px;
        height: auto;
        display: block;
        cursor: pointer;
    }
</style>
</head>

<body>
<div class="container">
    <h1>Happy Birthday ðŸŽˆ</h1>
    <canvas id="cakeCanvas" width="520" height="520"></canvas>
</div>

<script>
const canvas = document.getElementById("cakeCanvas");
const ctx = canvas.getContext("2d");

const center = { x: 260, y: 260 };
const radius = 170;
const cakeHeight = 90;
const maxCuts = 6;

let cuts = 0;
let flameOn = true;
let micStarted = false;

// Cake slices
let slices = [{
    start: 0,
    end: Math.PI * 2,
    offset: 0,
    toppings: []
}];

function makeToppings(start, end) {
    const arr = [];
    const count = 14;
    for (let i = 0; i < count; i++) {
        const angle = start + (i / count) * (end - start);
        arr.push({
            angle,
            r: radius * 0.6,
            seedR: radius * 0.72
        });
    }
    return arr;
}
slices[0].toppings = makeToppings(0, Math.PI * 2);

function drawCake() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const ordered = [...slices].sort(
        (a, b) => Math.sin((a.start + a.end) / 2) - Math.sin((b.start + b.end) / 2)
    );

    ordered.forEach(slice => {
        const mid = (slice.start + slice.end) / 2;
        const ox = slice.offset * Math.cos(mid);
        const oy = slice.offset * Math.sin(mid);

        // Chocolate sponge
        ctx.fillStyle = "#8b4513";
        ctx.beginPath();
        ctx.moveTo(center.x + ox, center.y + oy + cakeHeight);
        ctx.arc(center.x + ox, center.y + oy + cakeHeight, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        // Vanilla sponge
        ctx.fillStyle = "#f5deb3";
        ctx.beginPath();
        ctx.moveTo(center.x + ox, center.y + oy + cakeHeight / 2);
        ctx.arc(center.x + ox, center.y + oy + cakeHeight / 2, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        // Strawberry cream
        ctx.fillStyle = "#ff8fab";
        ctx.beginPath();
        ctx.moveTo(center.x + ox, center.y + oy);
        ctx.arc(center.x + ox, center.y + oy, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#c9184a";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Seeds & strawberries
        slice.toppings.forEach(t => {
            ctx.fillStyle = "#ffd166";
            ctx.beginPath();
            ctx.arc(
                center.x + ox + t.seedR * Math.cos(t.angle),
                center.y + oy + t.seedR * Math.sin(t.angle),
                2, 0, Math.PI * 2
            );
            ctx.fill();

            ctx.fillStyle = "#d00000";
            ctx.beginPath();
            ctx.arc(
                center.x + ox + t.r * Math.cos(t.angle),
                center.y + oy + t.r * Math.sin(t.angle),
                5, 0, Math.PI * 2
            );
            ctx.fill();
        });
    });

    drawCandle();
}

// ðŸŽ‚ Candle
function drawCandle() {
    const x = center.x;
    const y = center.y - radius - 35;

    // Candle body
    ctx.fillStyle = "#fff";
    ctx.fillRect(x - 6, y, 12, 35);

    // Wick
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y - 6);
    ctx.stroke();

    // Flame
    if (flameOn) {
        ctx.fillStyle = "#ffb703";
        ctx.beginPath();
        ctx.ellipse(x, y - 14, 6, 10, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Cake cutting
function cutCake() {
    if (cuts >= maxCuts) return;

    cuts++;
    const pieces = cuts + 1;
    const step = Math.PI * 2 / pieces;
    slices = [];

    for (let i = 0; i < pieces; i++) {
        const start = i * step;
        slices.push({
            start,
            end: start + step,
            offset: 0,
            toppings: makeToppings(start, start + step)
        });
    }
    animateSplit();
}

function animateSplit() {
    let t = 0;
    function anim() {
        t++;
        slices.forEach(s => s.offset = Math.min(40, t * 2));
        drawCake();
        if (t < 20) requestAnimationFrame(anim);
    }
    anim();
}

// ðŸŽ¤ Microphone candle blow
async function startMic() {
    if (micStarted) return;
    micStarted = true;

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const audioCtx = new AudioContext();
    const mic = audioCtx.createMediaStreamSource(stream);
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    mic.connect(analyser);

    const data = new Uint8Array(analyser.frequencyBinCount);

    function listen() {
        analyser.getByteFrequencyData(data);
        const volume = data.reduce((a, b) => a + b) / data.length;

        if (volume > 45 && flameOn) {
            flameOn = false;
            drawCake();
        }
        requestAnimationFrame(listen);
    }
    listen();
}

canvas.addEventListener("click", () => {
    cutCake();
    startMic(); // mic starts on first interaction
});

drawCake();
</script>
</body>
</html>
