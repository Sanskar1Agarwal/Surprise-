<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Happy Birthday ðŸŽˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body {
        margin: 0;
        background: #fff8f0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        font-family: Arial, sans-serif;
    }
    h1 {
        font-size: 48px;
        color: #d2691e;
        margin-bottom: 10px;
        white-space: nowrap; /* single line */
    }
    canvas {
        cursor: pointer;
    }
</style>
</head>
<body>

<h1>Happy Birthday ðŸŽˆ</h1>
<canvas id="cakeCanvas" width="500" height="500"></canvas>

<script>
const canvas = document.getElementById("cakeCanvas");
const ctx = canvas.getContext("2d");

const center = { x: 250, y: 270 };
const radius = 160;
const maxCuts = 6;

let cuts = 0;
let candleLit = true;

// Each slice has angle + offset
let slices = [{
    start: 0,
    end: Math.PI * 2,
    offset: 0,
    sprinkles: []
}];

// Pre-generate evenly distributed sprinkles PER SLICE
function generateSprinkles(start, end) {
    const sprinkles = [];
    const count = 12;
    for (let i = 0; i < count; i++) {
        const angle = start + (i / count) * (end - start);
        const r = radius * 0.6;
        sprinkles.push({
            angle,
            r,
            color: ["#ff4d4d", "#4dff4d", "#ffd84d", "#ff66cc"][i % 4]
        });
    }
    return sprinkles;
}

slices[0].sprinkles = generateSprinkles(0, Math.PI * 2);

// Draw cake
function drawCake() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    slices.forEach(slice => {
        const mid = (slice.start + slice.end) / 2;
        const ox = slice.offset * Math.cos(mid);
        const oy = slice.offset * Math.sin(mid);

        // Cake + icing gradient
        const grad = ctx.createRadialGradient(
            center.x + ox, center.y + oy, radius * 0.2,
            center.x + ox, center.y + oy, radius
        );
        grad.addColorStop(0, "#fff5ee");
        grad.addColorStop(0.4, "#ffd1b3");
        grad.addColorStop(1, "#f4a460");

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(center.x + ox, center.y + oy);
        ctx.arc(center.x + ox, center.y + oy, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#8b4513";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Sprinkles move WITH slice
        slice.sprinkles.forEach(s => {
            const x = center.x + ox + s.r * Math.cos(s.angle);
            const y = center.y + oy + s.r * Math.sin(s.angle);
            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
        });
    });

    drawCandle();
}

// Candle
function drawCandle() {
    const x = center.x;
    const y = center.y - radius - 30;

    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x - 5, y, 10, 35);

    if (candleLit) {
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(x, y - 5, 7, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Cut cake into equal slices
function cutCake() {
    if (cuts >= maxCuts) return;

    cuts++;
    const n = cuts + 1;
    const step = (Math.PI * 2) / n;
    slices = [];

    for (let i = 0; i < n; i++) {
        const start = i * step;
        const end = start + step;
        slices.push({
            start,
            end,
            offset: 0,
            sprinkles: generateSprinkles(start, end)
        });
    }

    animateSeparation();
}

// Slice separation animation
function animateSeparation() {
    let t = 0;
    function anim() {
        t++;
        slices.forEach(s => s.offset = Math.min(35, t * 2));
        drawCake();
        if (t < 20) requestAnimationFrame(anim);
    }
    anim();
}

// ðŸŽ¤ Microphone candle blowing (FIXED)
async function enableMic() {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const audioCtx = new AudioContext();
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;

    const mic = audioCtx.createMediaStreamSource(stream);
    mic.connect(analyser);

    const data = new Uint8Array(analyser.fftSize);

    function detectBlow() {
        analyser.getByteTimeDomainData(data);

        let sum = 0;
        for (let i = 0; i < data.length; i++) {
            const v = (data[i] - 128) / 128;
            sum += v * v;
        }
        const volume = Math.sqrt(sum / data.length);

        if (volume > 0.15 && candleLit) {
            candleLit = false;
            drawCake();
        }
        requestAnimationFrame(detectBlow);
    }
    detectBlow();
}

// Events
canvas.addEventListener("click", cutCake);

// Init
drawCake();
enableMic();
</script>

</body>
</html>
