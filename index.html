<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Happy Birthday Cake ðŸŽ‚</title>
<style>
    body {
        font-family: 'Arial', sans-serif;
        text-align: center;
        background: #fff8f0;
        padding: 30px;
    }
    h1 {
        color: #d2691e;
        font-size: 48px;
        margin-bottom: 20px;
    }
    canvas {
        border: none;
        margin-top: 20px;
        cursor: pointer;
        max-width: 90vw;
    }
    #info {
        margin-top: 20px;
        font-size: 20px;
        color: #8b4513;
    }
</style>
</head>
<body>

<h1>Happy Birthday ðŸŽˆ</h1>
<canvas id="cakeCanvas" width="500" height="500"></canvas>
<div id="info">Slices cut: 0 | Pieces: 1 | Candle: ðŸ”¥</div>

<script>
const canvas = document.getElementById('cakeCanvas');
const ctx = canvas.getContext('2d');
const radius = canvas.width/2 - 40;
const center = {x: canvas.width/2, y: canvas.height/2};
const maxCuts = 6;
let cutCount = 0;
let slices = [{start:0,end:2*Math.PI,offset:0}];
let candleLit = true;

// Even sprinkle positions
const sprinkleCount = 40;
let sprinkles = [];
for(let i=0;i<sprinkleCount;i++){
    const angle = (i/sprinkleCount)*2*Math.PI;
    const r = radius*0.6;
    sprinkles.push({x:center.x+r*Math.cos(angle), y:center.y+r*Math.sin(angle), color: ['#FF0000','#00FF00','#FFFF00','#FFA500','#FF69B4'][i%5]});
}

// Draw cake
function drawCake(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw cake slices
    slices.forEach(slice=>{
        const offsetX = slice.offset*Math.cos((slice.start+slice.end)/2);
        const offsetY = slice.offset*Math.sin((slice.start+slice.end)/2);

        const grad = ctx.createRadialGradient(center.x+offsetX, center.y+offsetY, radius*0.2, center.x+offsetX, center.y+offsetY, radius);
        grad.addColorStop(0,'#fff5e6'); // icing
        grad.addColorStop(0.3,'#FFDAB9'); // cake
        grad.addColorStop(1,'#FFB07C');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(center.x+offsetX, center.y+offsetY);
        ctx.arc(center.x+offsetX, center.y+offsetY, radius, slice.start, slice.end);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle='#8B4513';
        ctx.lineWidth=2;
        ctx.stroke();
    });

    // Draw evenly placed sprinkles on top (stable)
    sprinkles.forEach(s=>{
        ctx.beginPath();
        ctx.fillStyle=s.color;
        ctx.arc(s.x,s.y,5,0,Math.PI*2);
        ctx.fill();
    });

    // Draw candle on top
    const candleX = center.x;
    const candleY = center.y - radius - 20;
    ctx.fillStyle='#FFFFFF';
    ctx.fillRect(candleX-5,candleY,10,40); // candle stick

    // Flame
    if(candleLit){
        ctx.beginPath();
        ctx.fillStyle='orange';
        ctx.arc(candleX,candleY,8,0,Math.PI*2);
        ctx.fill();
    }
}

// Cut cake into equal slices
function cutCake(){
    if(cutCount>=maxCuts) return;
    cutCount++;
    const numSlices = cutCount;
    const angle = 2*Math.PI/numSlices;
    slices = [];
    for(let i=0;i<numSlices;i++){
        slices.push({start:i*angle,end:(i+1)*angle,offset:0});
    }
    animateSeparation();
    document.getElementById('info').innerText=`Slices cut: ${cutCount} | Pieces: ${numSlices} | Candle: ${candleLit?'ðŸ”¥':'ðŸ’¨'}`;
}

// Animate slices moving apart
function animateSeparation(){
    let step=0;
    const maxStep=20;
    function animate(){
        step++;
        slices.forEach(slice=>{
            slice.offset = (step/maxStep)*30;
        });
        drawCake();
        if(step<maxStep) requestAnimationFrame(animate);
    }
    animate();
}

// Reset cake
function resetCake(){
    cutCount=0;
    slices=[{start:0,end:2*Math.PI,offset:0}];
    candleLit = true;
    drawCake();
    document.getElementById('info')='Slices cut: 0 | Pieces: 1 | Candle: ðŸ”¥';
}

// Microphone blow detection
async function setupMic(){
    try{
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        source.connect(analyser);
        analyser.fftSize = 256;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        function detectBlow(){
            analyser.getByteFrequencyData(dataArray);
            const volume = dataArray.reduce((a,b)=>a+b)/dataArray.length;
            if(volume>100 && candleLit){ // threshold for blow
                candleLit=false;
                drawCake();
                document.getElementById('info').innerText=`Slices cut: ${cutCount} | Pieces: ${cutCount===0?1:cutCount} | Candle: ðŸ’¨`;
            }
            requestAnimationFrame(detectBlow);
        }
        detectBlow();
    }catch(err){
        console.log("Microphone access denied", err);
    }
}

// Events
canvas.addEventListener('click',cutCake);

// Initialize
drawCake();
setupMic();
</script>

</body>
</html>
